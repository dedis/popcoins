\chapter{PoP}

\paragraph{}
As already stated in the introduction, the backend for the PoP app is completely implemented in the Cothority framework, but it requires technical knowledge because one has to use the CLI to handle the functionalities. The first and main goal was to provide a user-friendly interface that is packaged in a cross-platform app for Android and iOS and allows anyone to use the technology provided by PoP. In this section, we describe the implementation of PoP in CPMAC and the process of creating, handling, and finalising a PoP party including the final PoP token creation.

\section{Implementation and Evaluation}

\paragraph{}
Three main classes form the PoP component: PoP.js, Org.js, and Att.js. The PoP.js object handles all information that is common or shared by the organiser and attendee status of a PoP party, for example the final statements and the PoP token the attendee owns. These are displayed in the PoP tab in the PoP drawer of the app. A final statement can be added by simply scanning a QR code provided by one of the organisers, deleting a final statement, generating a PoP token by linking it with the user’s key pair, and revoking PoP tokens to return to the final statement. When revoking a PoP token, the final statement is then restored, so the PoP token could now either be generated again by linking it with a key pair or the final statement can be deleted. This has been implemented so that the user can change the key pair linked to the PoP token if a mistake has been made.
The next class is Att.js, which, as mentioned previously, is only a skeleton for the class. At this point of development, this class is empty and acts only as a placeholder for future implementations that are specific to the attendee of a PoP party.

\paragraph{}
The last class is Org.js. This object is the most complicated one of the three as it has to handle every functionality that an organiser needs to create, handle, and finalise for a PoP party. The first step for an organiser is to link with a conode. This can be achieved by clicking on the corresponding button in the org tab in the PoP drawer. The organiser can then choose with which conode to link. The suggested conodes are the same ones registered in the home page. By clicking on the wanted server, the organiser is asked to enter a PIN (found in the server logs). If the correct PIN has been entered, the linked conodes name, description, public key, and ID are displayed in the org tab. This way, the conode to which an organiser last linked is always clear (but not a guarantee that the conode is still linked to the organiser). The displayed conode is the one that is contacted anytime a message needs to be sent. The next step is to fill in the configuration of the PoP party. This can be done by clicking on the corresponding button, which opens a new window. Then, it is necessary simply to enter the name, date, time, and location of the party. The last step of the configuration is to provide the roster so that the part can be hosted. Either the organiser can enter each conode manually or the QR codes of the other organisers can simply be scanned, which is the more convenient way to do it. Once the organiser has filled in the configuration, it can be easily shared with other organisers by displaying it as a QR code.

\paragraph{}
The process of sharing a PoP description could not be achieved using only a QR code, since the amount of data a code can contain is heavily restricted\footnote{\url{https://en.wikipedia.org/wiki/QR_code#Storage}}. Because of this restriction, we had to find a work around that permits organisers to share their configuration with other organisers. The current solution we propose is a third-party service called PasteBin\footnote{\url{https://pastebin.com}}. This means that when someone wants to share a configuration and displays the QR code, it is first uploaded to the PasteBin service. The QR code then displays the ID of the paste, and the other person , by scanning this code, then downloads the description from PasteBin. This solution is not ideal and should only be temporary until a better one can be implemented (see future works).

\paragraph{}
The other organisers could fill in the configuration too, but since they must be exact copies (the only exception is the order of the conodes in the roster), the description-sharing idea is highly recommended. Once all of the organisers have entered or imported the PoP party configuration, they have to save it on their respective conodes, which then returns an ID that should be identical for every organiser. After registering, the ID of the current PoP description is displayed in the org tab just under the currently linked conode and is now used for all subsequent actions. The next step is to register all of the attendees of the party. By clicking on the corresponding button in the org tab, a new window is displayed. On this page, the organiser can collect all of the public keys that should get registered. As always, either the public keys are entered by hand or it is possible to simply scan the QR code of the key pair. The order of the attendees is not important; however, organisers have to all register the same list of public keys as those that are not common to every conode are stripped out. Once all public keys are registered locally, they can be sent to the conodes by clicking on the register button (this finalises the PoP party on the respective conode). During this process, all organisers but the last one receives an error message that states that not all other conodes are finalised. Once the last organiser registers the attendees, everyone who received the error message can then return to the org tab and fetch the final statement by clicking on the corresponding button (the last one to finalise the PoP party automatically fetched it). By switching to the PoP tab, it should be possible to see the final statement. Organisers can now share this final statement with the attendees, and everyone can generate their PoP token by clicking on the final statement.

\paragraph{}
The process of linking to a conode and registering the PoP configuration (i.e., generating the ID of the party) are two crucial steps. During the linking process, the conode stores the public key of the organiser and then only accepts either messages that do not require a signature or signed messages that can be verified using this stored public key. The first signed message sent by the organiser is to register the PoP description. The ID is computed by hashing (in this paragraph, we always talk about SHA-256\footnote{\url{https://en.wikipedia.org/wiki/SHA-2}}) this description and the required signature along with the message in the ID signed using the Schnorr algorithm. The hash is computed by concatenating the strings of the name, date, time, and location and then appending the "aggregate" (point addition) of all of the public keys of the conodes that will host the PoP party. This forces the organisers to register exact copies of the party configuration (excluding the order of the conodes, thanks to commutativity). The second and last signed message sent by the organiser is the finalising request, which includes all registered attendees. The required signatures are the hash of the party ID concatenated with all of the public keys of the attendees. If either of the hashes are computed differently or signed using a private key that does not correspond to the public key stored on the conode, these messages are rejected.

\section{Results}

\paragraph{}
As of now, CPMAC is in its first development phase. The core libraries have been implemented, and currently only basic functionalities of CISC and PoP have been ported from the Cothority framework. For the PoP part, CPMAC enables anyone who wants to host or attend a PoP party to create, manage, attend, and finalise one. Moreover, it is possible to generate PoP tokens.

\paragraph{}
All of these functionalities have been implemented to be as user friendly as possible and should be more accessible to the public than the CLI that Cothority provided until now.

\section{Future Work}

\paragraph{}
As mentioned in the results section, only basic functionalities have been ported for now. However, all of the libraries and objects have been designed with the consideration that CPMAC will be extended by either providing CISC and PoP new functionalities or by even adding complete new Cothority apps like CoSi or Guard. Some possible future works are discussed below.

\begin{description}[style=nextline]
\item[Replacing PasteBin] The PasteBin service is currently used to share PoP configurations because they include too much data to be contained in a single QR code. This method relies on a third party, and it also exposes data (not sensitive, but still an undesirable situation) on the internet. In addition, it limits the number shares, as PasteBin only allows a certain number of pastes per 24 hours depending on the status of the user who created it (guest, member, pro). A solution that would lift all of these restrictions would be to implement a new fetch functionality directly into the PoP app of the Cothority framework. It is already possible to fetch the final statement from a conode with the knowledge of its ID, and thus the same procedure could be used to fetch the PoP description that corresponds to a certain ID. The new procedure would then require a first organiser to fill in the description, register it on that conode, and provide the others with the ID, and the remaining organisers would simply fetch the description from the first organiser’s conode and register it on their own.

\item[PoP Party Merging] It is possible for PoP parties to be merged. This means that people can organise multiple parties around the world and merge the final statements so that they are all considered as one single PoP party. This is useful if the generated PoP tokens should have the same proof value but people have to meet at different places.

\item[Viral PoP Parties] Once a PoP party is finalised, the final statement is registered on the hosting conodes. Moreover, all attendees listed in this statement are trusted people as they own a related PoP token. Attendees can then host a new PoP party on one of the hosting conodes using their PoP token as authentication (instead of linking to it by providing a PIN). This could ease the process of hosting PoP parties as an attendee without having to set up a conode.

\item[Sign and Verify Services] One of the main purposes of a PoP token is to be able to sign and verify different services. The token allows people to prove that they were at a certain location at a certain date and time, and thus it should provide some rights that were linked to the PoP party. As an example, we use the BeerToken suggested by the DeDiS laboratory. To begin, DeDiS would organise a PoP party and invite all of its members. The goal of the PoP party is to hand out PoP tokens called BeerTokens. A BeerToken would guarantee every attendee a free weekly beer at Satellite\footnote{\url{https://satellite.bar}}, the bar of EPFL. In order to make this possible, it would be required to either verify a BeerToken in order to know if the user has already ordered the one free beer of the week, or sign using a BeerToken to claim the weekly beer. All of this could be implemented in CPMAC by extending the core libraries and objects.
\end{description}
