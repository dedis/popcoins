# Acknowledgements

We would like to express our special thanks to Linus Gasser who gave us the opportunity to do this very interesting project related to the collective authority (Cothority) framework developed by the DeDiS laboratory at EPFL. We would like to thank him for the valuable help he gave us whenever we needed and for the knowledge he provided to us throughout the semester.
Secondly, we would also like to thank our parents and friends who helped us through the hard times of finalising the project within the limited time frame.

# Abstract(https://github.com/dedis/cothority/wiki)

The Cothority (https://github.com/dedis/cothority) framework has been developed and maintained by the DeDiS laboratory at EPFL. This project provides a framework for developing, analysing, and deploying decentralised and distributed cryptographic protocols. A set of servers that runs these protocols and communicates among each other is referred to as a collective authority, or cothority, and the individual servers are called cothority servers or conodes. A cothority that executes decentralised protocols could be used for collective signing, threshold signing, or the generation of public-randomness, to name only a few options. The highest level of abstraction can be created by protocols like the collective signature (CoSi) protocol, the random numbers (RandHound) protocol, or the communication (Messaging) protocol used by the conodes to exchange data. Then come the services, which rely on these protocols. As of this writing, there exist several services: the Status service to enquire into the status of a conode, the CoSi service for collective signing, the Guard service that allows for the distributed encryption and decryption of passwords, the SkipChain service for storing arbitrary data on a permissioned blockchain, and the Identity service for distributed key/value pair storage. Applications (also called “apps”) run on top of these services, including Status, CoSi, Guard, collective identity skipchains (CISC), and proof-of-personhood (PoP). In this project report, we only concentrate on the last two, CISC and PoP.

###### POP APP(https://github.com/dedis/cothority/wiki/PoP)
Anonymity on the internet is often a trade-off with accountability. Users want to be as anonymous as possible without losing rights and opportunities. This desire is in contrast with the needs of many online service providers who require this accountability to be able to provide users with a secure and high-quality experience. Captcha is one of the most frequently used methods to block non-human beings from accessing information. However, on one side, programs have become better and better at solving the Captcha queries, and on the other side, even human beings are occasionally unable to correctly decode a Captcha. The PoP app tries to remedy to this problem by providing so-called PoP Tokens, which can be considered to be a one-time captcha. These tokens are comparable to completely anonymous ID cards. The PoP Token proves that its holder is a human being who visited a specified place at a specified time, though it does so without revealing to which specific person the token refers.

# Contents

# Introduction

As CISC and PoP apps are completely implemented and functional only in the backend, it is difficult for casual users to use these technologies without investing ample time in the hands-on process of creating and running one or multiple conodes. The main purpose of this semester project is to lift this restriction and bring these technologies to the availability of the casual and non-technical user. In the past, in order to store data in an identity skipchain or hold a PoP party, it was necessary to use the command line interface (CLI), which is quite impractical and difficult to use. Providing the end user with an easy way to access the Cothority framework functionalities is a crucial part in the process of bringing this new technology into wide public use.

Almost everyone nowadays owns a smartphone, be it an Android device or an iPhone, most people have one in their pocket. The idea behind this project is to create a cross-platform mobile application for the Cothority (CPMAC), and thus make the functionalities as user friendly as possible so that this technology is accessible to almost everyone.
Starting with a simple proof of concept (PoC) for CISC and PoP as a mobile application, the final aim is to build this app such that further technologies in the Cothority framework are easily implementable and extensible. The JavaScript (JS) language has been chosen for this purpose, not only due to its popularity and simplicity, but also because it allows us the ability to write the entire application logic in a single language and compile it to run on both desired platforms, Android and iOS. With only few tweaks and changes (because of restricted libraries only available to NativeScript), the core logic of CPMAC could even be used to run web apps or desktop applications, as there are many frameworks that enable users to compile for these systems by writing the logic in JS. The framework we chose is called NativeScript (https://www.nativescript.org). The reasons behind this choice are simple. First, NativeScript makes it possible to have a real native app on Android and iOS without it running in so-called web views. Secondly, since the user interface (UI) is described in the XML format, it is cross-compatible i.e., the app does not have to be redesigned for each platform. Lastly, NativeScript is highly extensible with the use of NPM (https://www.npmjs.com) packages or even native Gradle (https://gradle.org) and CocoaPods (https://cocoapods.org) libraries for Android and iOS, respectively. This last reason provides zero-day support for native APIs.

# Background
## Cothority

The Cothority framework is composed of multiple protocols, services, and apps. At its current stage of development, CPMAC only supports the CISC and PoP apps, but it is intended to progressively feature and integrate more apps. We now present these two apps in more depth.

### POP

The PoP app of the cothority framework is used to generate and verify proof of personhood, which indicates that a user is a human being. Personhood is proven through stating that a specific person was at a precise location at a particular time and thus that this user is not a bot or any other kind of human-simulating program. Before continuing, we define some important terms:

First, all of the party organisers must agree on a date, time, and location. Once these specifications are set, all of the attendees (including the organisers) meet at the right location, date, and time. Each organiser has to link with a conode, complete the PoP configuration, and register it on his or her own conode; the organisers then receive the identification of this PoP party, which is henceforth used as a reference to uniquely identify it. Once every organiser registers the configuration and the PoP party is over, each one registers the list of all of the public keys of the attendees. During this step, the organisers have to ensure that each attendee has registered one and only one public key; this is a crucial step because otherwise an attendee could generate as PoP tokens for every public key that he or she registered. This would then contradict the important criterion that each human being is unique and thus should only receive one PoP token for each attended party. Once every organiser registered all of the attendees, the cothority composed of their conodes finalises the party by generating the final statement containing all relevant information, which includes a collective signature. This final statement is then sent to the attendees so that they can generate their PoP token by linking this final statement to their key pair.

# Design

In this chapter, we begin by presenting the main structure of the app, and then we further detail the different objects and libraries that have been implemented throughout the project.

The app itself uses a side drawer component to navigate between the main parts, such as the home screen, CISC, PoP, and settings. Each these drawers then splits in multiple tabs if needed in order to separate sub-sections of each component. In each tab, only the functionalities available to this sub-section of the component can be found. This is the main structure of the app, such that each main point is a drawer and each sub-point is a tab.

In order to easily represent the information, manage the data, and use the corresponding functionalities for all of these components, we chose to create multiple JS classes that are true singletons (as far as JS allows). Singletons permitted us to always work on the exact same object independently from the location we require for the class; since we had to store data locally, we had to load the saved states into memory for each of these classes. Because of the singleton design pattern, this loading must only be executed once, either at the start-up of the app or the first time the class is required, and all subsequent calls use this pre-loaded object. On the other hand, since we work with singletons, we were not able to create relationships between them; for example, the class that represents the organiser of a PoP party does not extend the main PoP class (each subclass instance would recreate their own parent class instance). The classes that have been implemented are listed below:

In addition to these objects, we wrote some libraries so that we can easily manipulate any kind of data, be it local or exchanged with conodes. The main libraries are presented as follows:

The classes and libraries in combination provide any required logic to execute the CISC and PoP apps locally but also to perform any communication needed with the conodes. We chose to implement these in such a way that it not only can be taken out as a whole and used as a library with as few tweaks and changes as possible for any other JS project related to the Cothority framework, but also so that it is easily extensible for other Cothority apps that will one day be implemented. We decided to call this aggregation of libraries "DeDjS".
Throughout the entire project, any data like keys, IDs, or EC points were handled as unsigned byte arrays (Uint8Array in JS) but shown to the user in the base64 (https://en.wikipedia.org/wiki/Base64) format (unless explicitly stated otherwise). This choice combines an easy way of handling the data and an easy way for the user to read the data on the screen. Moreover, since JS is an un-typed language, we decided to implement DeDjS so that it is as type safe as possible. This choice of implementation was made to prevent simple errors and return meaningful exception messages when a required type is incorrect.
Much of the logic in DeDjS requires writing and reading data to and from the disk or sending messages over the internet in order to use the functionalities of Cothority. These tasks are slow, generate delays, and even have a relatively high probability of failing. One of the challenges was to find a way to execute all of these tasks in an asynchronous way so as to not block the main thread of the app and handle exceptions in a simple and clean manner. The solution to this problem was that, since ECMAScript 2015 (https://en.wikipedia.org/wiki/ECMAScript), it is possible to use promises (https://en.wikipedia.org/wiki/Futures_and_promises, https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) in JS. Thus, we decided to implement DeDjS so that it uses promises anytime an asynchronous task is needed. In this way, the main thread of the app is never blocked, and the exceptions can easily be handled by the simple syntax provided by JS.

# App User

The user of the app is represented by a single class, the User.js object. This singleton handles all that is global to the app or the user and does not belong to CISC or PoP in particular, such as the roster displayed in the home drawer and the key pair managed in the user tab of the settings drawer. After the loading screen of the app, users land in the home drawer. Here, there are two main components: the roster of the user and a button to fetch the status of all of the user’s conodes. To add a new server, one can either enter the information manually or scan a QR code with either a JSON (https://www.json.org) or TOML (https://github.com/toml-lang/toml) description of the node. After being added to the roster, the status of all of the servers in the roster is fetched and can be re-fetched at any time with the corresponding button. To see the status of a conode, simply clicking on one of the conodes in the list opens a new page that contains all of the fetched stats of the conode. On top of this page is a button that permits the user to display a QR code to represent that particular conode. This permits convenient sharing of conodes, including when setting up a PoP party description.
The next functionalities of the user are located in the user tab in the settings drawer. Here, the user has the ability to generate a new key pair at any time, which is then displayed in this tab. Moreover, the user can display the key pair as QR code (with the private key removed). For example, this could be used for easy registration in a PoP party. The last button in the users’ settings completely resets any data related to the user, including the roster displayed in the home drawer and the key pair displayed in the settings.

# PoP

As already stated in the introduction, the backend for the PoP app is completely implemented in the Cothority framework, but it requires technical knowledge because one has to use the CLI to handle the functionalities. The first and main goal was to provide a user-friendly interface that is packaged in a cross-platform app for Android and iOS and allows anyone to use the technology provided by PoP. In this section, we describe the implementation of PoP in CPMAC and the process of creating, handling, and finalising a PoP party including the final PoP token creation.

## Implementation and Evaluation

Three main classes form the PoP component: PoP.js, Org.js, and Att.js.
The PoP.js object handles all information that is common or shared by the organiser and attendee status of a PoP party, for example the final statements and the PoP token the attendee owns. These are displayed in the PoP tab in the PoP drawer of the app. A final statement can be added by simply scanning a QR code provided by one of the organisers, deleting a final statement, generating a PoP token by linking it with the user’s key pair, and revoking PoP tokens to return to the final statement. When revoking a PoP token, the final statement is then restored, so the PoP token could now either be generated again by linking it with a key pair or the final statement can be deleted. This has been implemented so that the user can change the key pair linked to the PoP token if a mistake has been made.
The next class is Att.js, which, as mentioned previously, is only a skeleton for the class. At this point of development, this class is empty and acts only as a placeholder for future implementations that are specific to the attendee of a PoP party.
The last class is Org.js. This object is the most complicated one of the three as it has to handle every functionality that an organiser needs to create, handle, and finalise for a PoP party. The first step for an organiser is to link with a conode. This can be achieved by clicking on the corresponding button in the org tab in the PoP drawer. The organiser can then choose with which conode to link. The suggested conodes are the same ones registered in the home page. By clicking on the wanted server, the organiser is asked to enter a PIN (found in the server logs). If the correct PIN has been entered, the linked conodes name, description, public key, and ID are displayed in the org tab. This way, the conode to which an organiser last linked is always clear (but not a guarantee that the conode is still linked to the organiser). The displayed conode is the one that is contacted anytime a message needs to be sent. The next step is to fill in the configuration of the PoP party. This can be done by clicking on the corresponding button, which opens a new window. Then, it is necessary simply to enter the name, date, time, and location of the party. The last step of the configuration is to provide the roster so that the part can be hosted. Either the organiser can enter each conode manually or the QR codes of the other organisers can simply be scanned, which is the more convenient way to do it. Once the organiser has filled in the configuration, it can be easily shared with other organisers by displaying it as a QR code.
The process of sharing a PoP description could not be achieved using only a QR code, since the amount of data a code can contain is heavily restricted (https://en.wikipedia.org/wiki/QR_code#Storage). Because of this restriction, we had to find a work around that permits organisers to share their configuration with other organisers. The current solution we propose is a third-party service called PasteBin (https://pastebin.com). This means that when someone wants to share a configuration and displays the QR code, it is first uploaded to the PasteBin service. The QR code then displays the ID of the paste, and the other person , by scanning this code, then downloads the description from PasteBin. This solution is not ideal and should only be temporary until a better one can be implemented (see future works).
The other organisers could fill in the configuration too, but since they must be exact copies (the only exception is the order of the conodes in the roster), the description-sharing idea is highly recommended. Once all of the organisers have entered or imported the PoP party configuration, they have to save it on their respective conodes, which then returns an ID that should be identical for every organiser. After registering, the ID of the current PoP description is displayed in the org tab just under the currently linked conode and is now used for all subsequent actions. The next step is to register all of the attendees of the party. By clicking on the corresponding button in the org tab, a new window is displayed. On this page, the organiser can collect all of the public keys that should get registered. As always, either the public keys are entered by hand or it is possible to simply scan the QR code of the key pair. The order of the attendees is not important; however, organisers have to all register the same list of public keys as those that are not common to every conode are stripped out. Once all public keys are registered locally, they can be sent to the conodes by clicking on the register button (this finalises the PoP party on the respective conode). During this process, all organisers but the last one receives an error message that states that not all other conodes are finalised. Once the last organiser registers the attendees, everyone who received the error message can then return to the org tab and fetch the final statement by clicking on the corresponding button (the last one to finalise the PoP party automatically fetched it). By switching to the PoP tab, it should be possible to see the final statement. Organisers can now share this final statement with the attendees, and everyone can generate their PoP token by clicking on the final statement.
The process of linking to a conode and registering the PoP configuration (i.e., generating the ID of the party) are two crucial steps. During the linking process, the conode stores the public key of the organiser and then only accepts either messages that do not require a signature or signed messages that can be verified using this stored public key. The first signed message sent by the organiser is to register the PoP description. The ID is computed by hashing (in this paragraph, we always talk about SHA-256, https://en.wikipedia.org/wiki/SHA-2) this description and the required signature along with the message in the ID signed using the Schnorr algorithm. The hash is computed by concatenating the strings of the name, date, time, and location and then appending the "aggregate" (point addition) of all of the public keys of the conodes that will host the PoP party. This forces the organisers to register exact copies of the party configuration (excluding the order of the conodes, thanks to commutativity). The second and last signed message sent by the organiser is the finalising request, which includes all registered attendees. The required signatures are the hash of the party ID concatenated with all of the public keys of the attendees. If either of the hashes are computed differently or signed using a private key that does not correspond to the public key stored on the conode, these messages are rejected.

## Results

As of now, CPMAC is in its first development phase. The core libraries have been implemented, and currently only basic functionalities of CISC and PoP have been ported from the Cothority framework. For the PoP part, CPMAC enables anyone who wants to host or attend a PoP party to create, manage, attend, and finalise one. Moreover, it is possible to generate PoP tokens.
All of these functionalities have been implemented to be as user friendly as possible and should be more accessible to the public than the CLI that Cothority provided until now.

## Future Work

As mentioned in the results section, only basic functionalities have been ported for now. However, all of the libraries and objects have been designed with the consideration that CPMAC will be extended by either providing CISC and PoP new functionalities or by even adding complete new Cothority apps like CoSi or Guard. Here, I list some possible future works:

- Replacing PasteBin:
  The PasteBin service is currently used to share PoP configurations because they include too much data to be contained in a single QR code. This method relies on a third party, and it also exposes data (not sensitive, but still an undesirable situation) on the internet. In addition, it limits the number shares, as PasteBin only allows a certain number of pastes per 24 hours depending on the status of the user who created it (guest, member, pro). A solution that would lift all of these restrictions would be to implement a new fetch functionality directly into the PoP app of the Cothority framework. It is already possible to fetch the final statement from a conode with the knowledge of its ID, and thus the same procedure could be used to fetch the PoP description that corresponds to a certain ID. The new procedure would then require a first organiser to fill in the description, register it on that conode, and provide the others with the ID, and the remaining organisers would simply fetch the description from the first organiser’s conode and register it on their own.

- PoP Party Merging:
  It is possible for PoP parties to be merged. This means that people can organise multiple parties around the world and merge the final statements so that they are all considered as one single PoP party. This is useful if the generated PoP tokens should have the same proof value but people have to meet at different places.

- Viral PoP Parties:
  Once a PoP party is finalised, the final statement is registered on the hosting conodes. Moreover, all attendees listed in this statement are trusted people as they own a related PoP token. Attendees can then host a new PoP party on one of the hosting conodes using their PoP token as authentication (instead of linking to it by providing a PIN). This could ease the process of hosting PoP parties as an attendee without having to set up a conode.

- Sign and Verify Services:
  One of the main purposes of a PoP token is to be able to sign and verify different services. The token allows people to prove that they were at a certain location at a certain date and time, and thus it should provide some rights that were linked to the PoP party. As an example, we use the BeerToken suggested by the DeDiS laboratory. To begin, DeDiS would organise a PoP party and invite all of its members. The goal of the PoP party is to hand out PoP tokens called BeerTokens. A BeerToken would guarantee every attendee a free weekly beer at Satellite (https://satellite.bar), the bar of EPFL. In order to make this possible, it would be required to either verify a BeerToken in order to know if the user has already ordered the one free beer of the week, or sign using a BeerToken to claim the weekly beer. All of this could be implemented in CPMAC by extending the core libraries and objects.

# Known Bugs
As it is relatively new, NativeScript still exhibits some unexpected behaviours for which we had to find solutions. We now discuss some know bugs that have been bypassed or are still problematic.

- Compressed Files (Android)
Some NPM libraries are shipped with compressed files that usually end with ".gz" and are also included in their non-compressed form.
Android interprets these as a same and single file, this means that at compilation time Gradle will throw a "duplicate resources" error. To bypass this bug, we automatically delete the compressed version(they are not needed at runtime)) before they get compiled. You can find the corresponding commands in the "prepare-hook.sh" bash script.

- The BroRand Library(https://www.npmjs.com/package/brorand)
BroRand is a JS library to generate random numbers. CPMAC makes indirectly use of BroRand through the EC library called elliptic(https://www.npmjs.com/package/elliptic). BroRand is not fully supported on the NativeScript framework and throws an error at execution time when trying to generate a random number. We bypassed this by adapting the problematic lines in such a way that it works with NativeScript. You can find the corresponding command in the "prepare-hook.sh" bash script and the modified code in the "brorand-fix" folder

- WebSocket Bug (iOS)
The websocket library for NativeScript does not work correctly when run on iOS. Currently we didn't find a way to correct this bug in any way. The used library is called "nativescript-websockets"(https://www.npmjs.com/package/nativescript-websockets). Basically, this library wraps native websockets libraries for Android and iOS in JS objects. It seems that the wrapper implemented by "nativescript-websockets" is working properly, but that either the underlying native Objective-C library, which is a slightly modified version of PocketSocket(https://github.com/NathanaelA/PocketSocket), or iOS itself is causing troubles. It seems that either PocketSocket or iOS is resending previous messages by concatenating it with some new data. Below are two sent messages and the corresponding received messages by a conode, they are displayes in byte and base64 format to be easily readable. We verified that the sent messages are properly passed down to the native library by the JS wrapper. The first message is an empty pin request, thus only contains the public key of the organizer and is correctly received by the conode. The second message, which now also contains the PIN printed by the conode is not received correctly. The received message is the first message concatenated by six zeros and then the beginning of the second message.

As already stated before, we were not able to bypass or fix this bug. Here is a non-exhaustive list of what we already tried but didn't succeed: ...
