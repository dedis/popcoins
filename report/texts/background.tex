\section{Corresponding background}
As CP-MAC aims to provide an intuitive and user friendly interface to access the Cothority framework, multiple technologies have been abstracted into the application to give regular users the possibility to use the application without having to know the inner working of the frameworks it uses. During this project, this idea was kept in mind and influenced the different decisions that had to be made. 

In this section, I will present the different technologies involved in this project and their role in the application. Note that there are several other technologies on which CP-MAC resides that are not described in this section, as they were not implicated in the realization of the project. Thus, if complementary information is needed to understand other specific parts of the application, please refer to the report covering its first implementation\cite{petrimaire2018}. The last part of this section will then focus on the state of the application as it was before the project and which aspects this project have improved. These aspects will then be detailed during the rest of the report.


\subsection{Cothority}
The genesis of the CP-MAC application begins with the framework Cothority, developed by the DEDIS laboratory at the EPFL. The Cothority (short name for \textit{collective authority}) framework provides the necessary components to deploy decentralized protocols over a set of servers, individually referred as a \textit{conode}.  The framework is based on a list of protocols that resolve the most basic challenges of the framework, such as \textit{ByzCoinX\footnote{\url{https://github.com/dedis/cothority/tree/master/byzcoinx}}} that implements the consensus protocol, or \textit{dkg\footnote{\url{https://github.com/dedis/cothority/tree/master/ocs/protocol/DKG.md}}} that implements a distributed key generation protocol. However, in order to use these protocols, Cothority provides services that allows user to communicate with a conode and abstract the protocols. Examples of services are \textit{skipchains\footnote{\url{https://github.com/dedis/cothority/blob/master/skipchain}}}, that defines a permissioned blockchain for storing data, or \textit{cosi\footnote{\url{https://github.com/dedis/cothority/tree/master/cosi}}} that allows a user to get a collective signature of an arbitrary document from the set of conodes.

More generally, a combination of services and protocols defines a Cothority application, which is a high level abstraction to define a useful usage for a set of conodes. The scope is then quite broad, starting from simple command line interface for a specific service to more complex combinations, such as \textit{CISC Identy Skipchain\footnote{\url{https://github.com/dedis/cothority/tree/master/cisc}}}, an extension of the more basic skipchain service that contains, inter alia, a module to handle distributed SSH keys rotation. I will now describe the Cothority application which has been involved in this project, the Proof-Of-Personhood.
\subsubsection{Proof-Of-Personhood}
The Proof-Of-Personhood results from the work done by Maria Fernanda Borge Chavez at the DEDIS laboratory. She proposes a way to solve a known problem on the Internet, which is the ability for a given service to recognize an user without compromising his anonymity, for example if a user is allowed to get only a specific amount of an arbitrary resource but doesn't want to disclose its identity. To achieve this, every member of a specific group gets a token that can be used to authenticate himself towards a service. This will also generate a tag, specific to the user and the service, which can be used to recognize that user (more information about this process is available at section \ref{sec:linkable_ring_signature}: \nameref{sec:linkable_ring_signature}). As the tag will be different among the services, they cannot team up to exclude or identify a specific user. The generation of these tokens is the key topic of her work.

More specifically, two types of actor take part in the generation of the tokens: the organizers and the attendees. Each organizer has a conode, which will be used for the registrations and the cryptographic operations. On the other side, each attendee have their own key pair, which corresponds to a specific identity. This being set up, the following steps can be achieved:

\begin{itemize}
	\item First, the organizers have to define the conditions of a \textbf{PoP-Party}, which is a meeting between all the organizers and attendees. These conditions contain the location, the date, and the list of the organizers' conodes. This is called the \textbf{Party Description}. It has to be the exact same for every organizer, as the hash of the description is used to identify the party.
	\item At the given date and location, every organizer and attendee meet. Each attendee has to pass in front of each organizer to get his public key registered (i.e, adding his public key to the set of all the attendees' public key to later prove that he was present at this party). Of course, some precautions have to be taken to prevent an attendee to register multiple times with different keys. For example, each attendee could be marked with permanent pen while leaving the room, which prevents him to go back in and get registered again.
	\item Once every attendee is registered, the organizers can \textbf{Finalize} the party. The list of public keys is added to the end of the party description, and a collective signature of this file among all the organizer conodes is generated. By combining the file and its signature, we get a \textbf{Final Statement}, which is the necessary material to verify a signed message. In the other side, the attendee combines the final statement with his key pair, which results in a \textbf{PoP-Token}.
	\item Using Linkable Ring Signature (see \ref{subsubsec:linkable_ring_signature}) and PoP-Token, a user can sign a message, which can then be verified by the holder of the final statement.
\end{itemize}

Of course, all of these steps are implemented in the Proof-of-Personhood application of Cothority and can be accessed using an API\footnote{\textit{Application Programming Interface}}.

\subsection{Kyber}
The Kyber library\footnote{\url{https://github.com/dedis/kyber}} is a key element in the Cothority framework. It provides a toolbox for all the cryptographic operations that are needed. Especially, it supports all the algebraic operations on group elements (such as elliptic curve points and scalars), as well as random generators and elements mar\-shaling. It's implemented in Go, but as a lot of front-end applications (such as CP-MAC) require a JavaScript implementation, a partial and develop\-mental port named KyberJS is available. However, it is important to note that some features from Kyber are not available in KyberJS, such as extendable-output functions (see point \ref{subsubsec:blake2} for more information) or (Linkable) Ring Signature (see \ref{subsubsec:linkable_ring_signature}). In this project, a special implementation of the latter has been made as it became necessary for the evolution of the application. Its implementation is described at section \ref{sec:linkable_ring_signature}.
\subsubsection{(Linkable) Ring Signature}
\label{subsubsec:linkable_ring_signature}
Ring signature gives the possibility for a user to sign a message on behalf of a group, in the sense that the receiver of such a message will be able to verify that the signer is indeed a member of the group without revealing who specifically signed it. Here, each group member is represented by his public key. This leads to interesting applications, as the only constraint to create such an anonymity set is to have the public key of each member. For detailed information about the inner working of ring signatures, please refer to the original publication at \cite{rivest2001}.

Kyber also provides the possibility to create linkable ring signatures, which implementation follows the paper \cite{cryptoeprint:2004:027}. The additional property that linkable ring signatures asserts is that two signatures from the same signer can be linked. In other words, a link scope is used during the signing and verification process, then, in addition to the signature, a linkage tag is produced. This tag is unique to the user and to this scope. Thus, given two messages signed under the same linked scope, the verifier of the signature can assert (1) whether the signers are members of the group or not and (2) whether the two signers are the same member or two different ones. A tag can also be used to remember if a specific user have already been "seen" under the current link scope. This application will be particularly useful in CP-MAC. More generally, useful applications can be found for linkable ring signature. For example, different services (Wikipedia, E-Voting, and so forth) could get their own view on a group, without them being able to collude to find out link between users, or to exclude specific users.
\subsubsection{BLAKE2}
\label{subsubsec:blake2}
During the signature and verification process of linkable ring signatures (as defined by \cite{cryptoeprint:2004:027}) a cryptographic hash function is required. In Kyber, this task is handled by the BLAKE2 function. BLAKE2 comes with several interesting characteristics : it's faster than most of the current popular hash function (SHA or MD5) and it's at least as secure as SHA-3 (see \cite{aumasson2014}). BLAKE2 is available in two versions :
\begin{itemize}
	\item BLAKE2b, which produces digests of size up to 64 bytes and is optimized for 64 bits processors
	\item BLAKE2s, which produces digests of size up to 32 bytes and is optimized for 32 bits processors
\end{itemize}

\subsubsection*{Extendable-output functions}
BLAKE2 also offers the possibility to generate extendable-output functions (XOFs) from each variants of BLAKE2, respectively named BLAKE2Xb and BLAKE2Xs. A XOF allows generating digest of arbitrary length (although there is a limit of 256 GiB for BLAKE2Xb and of 128 GiB for BLAKE2Xs), which is especially interesting to create deterministic random bit generators (DRBG). In Kyber, both of BLAKE2 versions and their respective XOF are implemented and BLAKE2Xb is used in the computation of ring signatures. However, these XOFs have not been ported yet to KyberJS.

\subsection{CP-MAC}
As CP-MAC has already been extensively presented in \cite{petrimaire2018}, I will rather do a quick overview of the application and then focus on the state of the application as it was before the beginning of this project. This will then allow me to present the road map of the execution of the project to underline the components of the application that have been improved.

CP-MAC implements a simple interface to use two major applications of the Cothority framework : the Proof-Of-Personhood and the CISC Identity Skipchain. However, these are services that are though to use for a non-experimented user who doesn't have access to an easy-to-use front-end. CP-MAC tries to resolve this problem by combining the mobility offered by a smartphone application with a  more intuitive user interface than CLI\footnote{\textit{Command Line Interface}}.

\subsubsection*{NativeScript}
Under the hood, CP-MAC is made above the NativeScript framework, which allows developing a native cross-platform mobile application in JavaScript (for the application logic), XML (for UI elements) and CSS (for UI styling). It is a great advantage, as styling an application on NativeScript is essentially the same as styling a website, apart from some exceptions. The vast majority of CSS attributes are available, even some advanced ones, such as animations. Also, on both platform, NativeScript allows calls to native APIs such as \textit{Time} on Android, or \textit{UIAlertView} on iOS. It's then possible to manipulate directly those objects from the JavaScript code. 

Also, NativeScript gives the possibility to create Plugins, which are native pieces of code with a common JavaScript interface. For example, one could develop advanced Plugins such as Web Sockets or Fingerprint Authentication that have their specific native implementations on iOS and Android, but that will be manipulated through a single object in JavaScript. 

It's however important to note that NativeScript does not directly compile JavaScript to native code. Instead, it uses the power of JavaScript virtual machines to inject global objects representing the native APIs, that are then used to intercept native calls and let NativeScript Runtime redirect them to the native libraries. Apart from that, the application logic is executed in JavaScript by their respective engine, i.e \textit{V8} on Android and \textit{JavaScriptCore} on iOS\footnote{as of June 2018}.


